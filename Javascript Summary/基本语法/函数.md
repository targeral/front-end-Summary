# 1.概述
## 1.1函数的声明
### 1.1.1function命令

```javascript
function print() {

}
```

### 1.1.2函数表达式

```javascript
var print = function() {

};
```

右侧的匿名函数称为函数表达式

采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。

### 1.1.3Function构造函数
## 1.2函数的重复声明
如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。

## 1.3圆括号运算符,return语句和递归
函数体内部的return语句，表示返回。JavaScript引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined

## 1.4第一等公民
JavaScript的函数与其他数据类型（数值、字符串、布尔值等等）处于同等地位，可以使用其他数据类型的地方，就能使用函数

## 1.5函数名的提升
## 1.6不能在条件语句中声明函数(包括try)
# 2.函数的属性和方法
## 2.1name属性
## 2.2length属性
length属性返回函数预期传入的参数个数，即函数定义之中的参数个数

length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的"方法重载"（overload）。

## 2.3toString()
函数的toString方法返回函数的源码。

函数内部的注释也可以返回

# 3.函数作用域
## 3.1定义
作用域分为全局作用域和函数作用域

## 3.2函数内部的变量提升
## 3.3函数本身的作用域
函数本身也是一个值，也有自己的作用域。它的作用域绑定其声明时所在的作用域。

**很容易犯错的一点是，如果函数A调用函数B，却没考虑到函数B不会引用函数A的内部变量。**

# 4.参数
## 4.1概述
## 4.2参数的省略
_没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。_

## 4.3默认值

```JavaScript
function f(a){
  a = a || 1;
  return a;
}

f('') // 1
f(0) // 1
```

上面代码的||表示"或运算"，即如果a有值，则返回a，否则返回事先设定的默认值（上例为1）。

这种写法会对a进行一次布尔运算，只有为true时，才会返回a。可是，除了undefined以外，0、空字符、null等的布尔值也是false。也就是说，在上面的函数中，不能让a等于0或空字符串，否则在明明有参数的情况下，也会返回默认值。

为了避免这个问题，可以采用下面更精确的写法。

```javascript
function f(a) {
  (a !== undefined && a !== null) ? a = a : a = 1;
  return a;
}

f() // 1
f('') // ""
f(0) // 0
```

## 4.4传递方式
- 原始类型传递是值传递；
- 引用类型传递是传址传递，如果在函数内部修改参数，将会影响到原始值。
- **注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值**

某些情况下，如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性。

```javascript
var a = 1;

function f(p) {
  window[p] = 2;
}
f('a');

a // 2
```

## 4.5同名参数
如果有同名的参数，则取最后出现的那个值

## 4.6arguments对象
### 4.6.1callee属性
arguments对象带有一个callee属性，返回它所对应的原函数。

# 5.函数的其他知识点
## 5.1闭包
闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。

```javascript
function createIncrementor(start) {
  return function() {
    return start++;
  };
}

var inc = createIncrementor(5);
inc() //5
inc() //6
inc() //7
```

闭包的另一个用处，是封装对象的私有属性和私有方法。

```javascript
function Person(name) {
  var _age;
  function setAge(n) {
    _age = n;
  }
  function getAge() {
    return _age;
  }

  return {
    name: name,
    getAge: getAge,
    setAge: setAge
  };
}

var p1 = person('张三');
p1.setAge(25);
p1.getAge() // 25
```

**注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。**

## 5.2立即调用的函数表达式(IIFE)
有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误

产生这个错误的原因是，JavaScript引擎看到function关键字之后，认为后面跟的是函数定义语句，不应该以圆括号结尾。

解决方法就是让引擎知道，圆括号前面的部分不是函数定义语句，而是一个表达式，可以对此进行运算。你可以这样写

```javascript
(function(){}());
//或者
(function(){})();
```

这两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义，所以就避免了错误。这就叫做"立即调用的函数表达式"（Immediately-Invoked Function Expression），简称IIFE。_注意，上面的两种写法的结尾，都必须加上分号。_

由此可以推之:

```javascript
var i = function(){ return 10; }();

true && function(){ /* code */ }();

0, function(){ /* code */ }();

!function(){ /* code */ }();

~function(){ /* code */ }();

-function(){ /* code */ }();

+function(){ /* code */ }();

new function(){ /* code */ }

new function(){ /* code */ }() // 只有传递参数时，才需要最后那个圆括号
```

通常情况下，只对匿名函数使用这种"立即执行的函数表达式"。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。

# 6.函数——《javascript精粹》
## 6.1调用
调用一个函数将暂停当前函数的执行，传递控制和参数给新函数 调用模式:
1. 方法调用
2. 函数调用
3. 构造器调用
4. apply调用
