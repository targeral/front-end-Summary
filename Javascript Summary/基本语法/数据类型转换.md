# 1.强制转换
## 1.1Number函数
### 1.1.1原始类型值的转换规则
- undefined：转成NaN。
- null：转成0。
- 字符串：如果可以被解析为数值，则转换为相应的数值，否则得到NaN。空字符串转为0。

Number会忽略八进制的前导0，Number函数会自动过滤一个字符串前导和后缀的空格

### 1.1.2对象的转换规则
1. 先调用对象自身的valueOf方法，如果该方法返回原始类型的值（数值、字符串和布尔值），则直接对该值使用Number方法，不再进行后续步骤。
2. 如果valueOf方法返回复合类型的值，再调用对象自身的toString方法，如果toString方法返回原始类型的值，则对该值使用Number方法，不再进行后续步骤。
3. 如果toString方法返回的是复合类型的值，则报错。

## 1.2String函数
## 1.2.1原始类型值的转换规则
- undefined：转为"undefined"。
- null：转为"null"。
- true转为"true"，false转为"false"。

## 1.2.2对象的转换规则
- 先调用toString方法，如果toString方法返回的是原始类型的值，则对该值使用String方法，不再进行以下步骤。
- 如果toString方法返回的是复合类型的值，再调用valueOf方法，如果valueOf方法返回的是原始类型的值，则对该值使用String方法，不再进行以下步骤。
- 如果valueOf方法返回的是复合类型的值，则报错。

## 1.3Boolean函数：强制转换成布尔值
### 1.3.1原始类型值的转换方法
以下六个值的转化结果为false，其他的值全部为true。
- undefined
- null
- -0
- +0
- NaN
- ''（空字符串）

### 1.3.2对象的转换规则
所有对象的布尔值都是true，甚至连false对应的布尔对象也是true。

# 2.加法运算符的类型转化
## 2.1三种情况
### 2.1.1运算式之中存在字符串
两个运算子之中，只要有一个是字符串，则另一个不管是什么类型，都会被自动转为字符串，然后执行字符串连接运算

### 2.1.2两个运算式都为数值或布尔值
这种情况下，执行加法运算，布尔值转为数值（true为1，false为0）

### 2.1.3运算子之中存在对象
运算子之中存在对象（或者准确地说，存在非原始类型的值），则先调用该对象的valueOf方法。如果返回结果为原始类型的值，则运用上面两条规则；否则继续调用该对象的toString方法，对其返回值运用上面两条规则

## 2.2四个特殊表达式
### 2.2.1空数组 + 空数组

```javascript
[] + []
// ""
```

### 2.2.2空数组 + 空对象

```javascript
[] + {}
// "[object Object]"
```

### 2.2.3空对象 + 空数组

```javascript
{} + []
// 0

({}) + []
// "[object Object]"
```

JavaScript引擎将空对象视为一个空的代码块，加以忽略。因此，整个表达式就变成"+ []"，等于对空数组求正值，因此结果就是0。

如果JavaScript不把前面的空对象视为代码块，则结果为字符串"[object Object]"。

### 2.2.4空对象 + 空对象

```JavaScript
{} + {}
// NaN
```
