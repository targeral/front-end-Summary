# 腾讯面试——AlloyTeam
## 一面
### 谈谈为什么使用koa
koa这个框架首先它很轻，它提供了一个轻量的函数库。相比express，他没有绑定router，路由规则，视图渲染这些功能。他只提供一个架子，而使用者根据自己的需求来选择第三方中间件。

第二点就它将node的request和response对象封装在一个单独的对象context里面，其为编写web应用和API提供了很多有用的方法。 由此很多任务和功能就需要在中间件实现，context 在每个request 请求中被创建，中间件中通过context作为接收器来引用或者 this标识符来引用，这样也可以自己编写中间件来满足需求。

第三点就是no callback，在使用node开发中，会频繁使用回调。有时候就可能由于太多的回调使得代码太过于复杂而难读。 koa则是使用了es6的新特性generator函数可以无需写回调函数。generator函数可以理解为一个状态机，封装了很多内部状态。执行generator函数会返回一个遍历器对象，通过调用遍历对象的next方法可以遍历generator函数内部的每一个状态。每当遇到一个yield,它就会暂停执行。它有两个特征，一个是function关键字与函数名之间有一个星号，二是，函数体内部使用yield语句定义不同的内部状态。同时在一个generator函数内部可以调用另一个generator函数。generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到用到next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，等到调用next方法再去执行。koa则是将用户的请求通过中间件，遇到yield next关键字时，会被传递到下一个符合请求的路由(downstream)，在yield next捕获不到下一中间件时，会逆序返回继续执行代码(upstream).

### 谈谈koa的整个运行流程&&谈谈关于Generator函数的理解&&谈谈关于koa的中间件
详见![koa](koa/readme.md)

### TCP三次握手
第一次握手：建立连接时，客户端发送syn包到服务器，并进入SYN_SEND状态，等待服务器确认；SYN：同步序列编号(Synchronize Sequence Numbers); 第二次握手:服务器收到syn包，必须确认客户的SYN(ack = j+1 ),同时自己也要发送一个SYN包(syn = k),即SYN + ACK包，此时服务器进入SYN_RECV状态。 第三次握手:客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK，此时包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

一个完整的三次握手也就是：**请求---应答---再次确认。**

### TCP与UDP的区别
_UDP_ ：
- UDP是无连接的(在传送数据之前不需要建立连接,因此减少了开销和发送数据之前的延迟)。
- 尽最大努力交付(即不保证可靠交付，因此主机不需要维持复杂的连接状态)
- UDP是面向报文的。(主要体现在，应用层交给UDP多长的报文，UDP就照常发送，即一次发送一个报文)
- UDP没有拥塞控制
- UDP支持一对一，一对多，多对一和多对多的交互通信。
- UDP的首部开销小

_TCP_ ：
- TCP是面向连接的运输层协议(三次握手)
- 每一条TCP连接只能有两个端点(即每一条TCP连接只能是点对点的)
- TCP提供可靠交付的服务。(也就是说通过TCP连接传送的数据，无差错，不丢失，不重复，并且按序到达)
- TCP提供全双工通信。
- 面向字节流。
